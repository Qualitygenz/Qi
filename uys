local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "Quality x",
    Icon = "rbxassetid://138614699274576",
    Author = "Hello, I'm Txr, I'm cool.",
    Folder = "MySuperHub",
    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 200,
    BackgroundImageTransparency = 0.42,
    HideSearchBar = true,
    ScrollBarEnabled = false,
    User = {
        Enabled = true,
        Anonymous = false,
        Name = LocalPlayer.Name,
        Image = "rbxthumb://type=AvatarHeadShot&id=" .. LocalPlayer.UserId,
        Callback = function() end,
    },
})

Window:EditOpenButton({ Enabled = false })

local ScreenGui = Instance.new("ScreenGui")
local ToggleBtn = Instance.new("ImageButton")

ScreenGui.Name = "WindUI_Toggle"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = CoreGui

ToggleBtn.Size = UDim2.new(0, 50, 0, 50)
ToggleBtn.Position = UDim2.new(0, 20, 0.5, -25)
ToggleBtn.BackgroundTransparency = 1
ToggleBtn.Image = "rbxassetid://138614699274576" 
ToggleBtn.Active = true
ToggleBtn.Draggable = true
ToggleBtn.Parent = ScreenGui

local opened = true

local function toggle()
    opened = not opened
    if Window.UI then
        Window.UI.Enabled = opened
    else
        Window:Toggle()
    end
end

ToggleBtn.MouseButton1Click:Connect(function()
    ToggleBtn:TweenSize(
        UDim2.new(0, 56, 0, 56),
        Enum.EasingDirection.Out,
        Enum.EasingStyle.Quad,
        0.12,
        true,
        function()
            ToggleBtn:TweenSize(
                UDim2.new(0, 50, 0, 50),
                Enum.EasingDirection.Out,
                Enum.EasingStyle.Quad,
                0.12,
                true
            )
        end
    )
    toggle()
end)

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.T then
        toggle()
    end
end)


if not LocalPlayer.Character then
LocalPlayer.CharacterAdded:Wait()
end


local CombatTab   = Window:Tab({Title = "Combat",   Icon = "crosshair"})
local PlayersTab   = Window:Tab({Title = "Players",   Icon = "user"})
local EspTab   = Window:Tab({Title = "Esp",   Icon = "eye"})
local MiscTab   = Window:Tab({Title = "Misc",   Icon = "ltable-of-contents"})
local ServerTab   = Window:Tab({Title = "Server",   Icon = "server"})

--// ================= STATE (à¹€à¸›à¸´à¸”à¸•à¸¥à¸­à¸”) =================
local SilentAimEnabled = true      -- à¹€à¸›à¸´à¸”à¸•à¸¥à¸­à¸”
local TracerEnabled   = true       -- à¹€à¸›à¸´à¸”à¸•à¸¥à¸­à¸”
local ShowFOV         = false       -- à¸„à¸¸à¸¡à¸”à¹‰à¸§à¸¢ UI
local FOV             = 150        -- à¸„à¸¸à¸¡à¸”à¹‰à¸§à¸¢ Slider

--// ================= GUN LIST (à¸¥à¸´à¸ªà¸•à¹Œà¸¥à¹‰à¸§à¸™) =================
local GunNames = {
	"P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9",
	"Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"
}

--// ================= FOV CIRCLE =================
local fovCircle = Drawing.new("Circle")
fovCircle.Color = Color3.fromRGB(255,255,255)
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Filled = false
fovCircle.Visible = ShowFOV
fovCircle.Radius = FOV

--// ================= TRACER =================
local tracerLine = Drawing.new("Line")
tracerLine.Color = Color3.fromRGB(255,0,0)
tracerLine.Thickness = 2
tracerLine.Visible = false

--// ================= TARGET FINDER =================
local function GetClosestTarget()
	local closest, shortest = nil, math.huge
	local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

	for _, plr in pairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer
			and not plr:GetAttribute("SilentAimIgnore")
			and plr.Character
			and plr.Character:FindFirstChild("Head") then

			local pos, onScreen = Camera:WorldToViewportPoint(plr.Character.Head.Position)
			if onScreen then
				local dist = (Vector2.new(pos.X, pos.Y) - center).Magnitude
				if dist < FOV and dist < shortest then
					shortest = dist
					closest = plr
				end
			end
		end
	end

	return closest
end

--// ================= GUN CHECK =================
local function IsHoldingAllowedGun(args)
	-- à¹€à¸Šà¹‡à¸„à¸ˆà¸²à¸ remote args à¸à¹ˆà¸­à¸™
	local ok, weapon = pcall(function()
		return args[3]
	end)

	if ok and typeof(weapon) == "Instance" and weapon.Name
		and table.find(GunNames, weapon.Name) then
		return true
	end

	-- à¹€à¸Šà¹‡à¸„à¸ˆà¸²à¸à¸•à¸±à¸§à¸¥à¸°à¸„à¸£
	if LocalPlayer.Character then
		for _, v in pairs(LocalPlayer.Character:GetChildren()) do
			if (v:IsA("Tool") or v:IsA("Model"))
				and v.Name
				and table.find(GunNames, v.Name) then
				return true
			end
		end
	end

	return false
end

--// ================= HOOK REMOTE =================
local send = ReplicatedStorage.Remotes.Send
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
	local args = {...}

	if SilentAimEnabled and IsHoldingAllowedGun(args) then
		local target = GetClosestTarget()
		if target and target.Character and target.Character:FindFirstChild("Head") then
			local head = target.Character.Head
			args[4] = CFrame.new(math.huge, math.huge, math.huge)
			args[5] = {
				[1] = {
					[1] = {
						Instance = head,
						Position = head.Position
					}
				}
			}
		end
	end

	return oldFire(self, unpack(args))
end)

--// ================= RENDER LOOP =================
RunService.RenderStepped:Connect(function()
	fovCircle.Position = Vector2.new(
		Camera.ViewportSize.X/2,
		Camera.ViewportSize.Y/2
	)
	fovCircle.Radius = FOV
	fovCircle.Visible = ShowFOV

	local target = GetClosestTarget()
	if TracerEnabled
		and target
		and target.Character
		and target.Character:FindFirstChild("Head")
		and LocalPlayer.Character
		and LocalPlayer.Character:FindFirstChild("Head") then

		local tPos, tOn = Camera:WorldToViewportPoint(target.Character.Head.Position)
		local mPos, mOn = Camera:WorldToViewportPoint(LocalPlayer.Character.Head.Position)

		if tOn and mOn then
			tracerLine.From = Vector2.new(mPos.X, mPos.Y)
			tracerLine.To   = Vector2.new(tPos.X, tPos.Y)
			tracerLine.Visible = true
			return
		end
	end

	tracerLine.Visible = false
end)

--// ================= UI (à¹€à¸‰à¸žà¸²à¸° Show FOV + Slider) =================
do
	CombatTab:Toggle({
		Title = "Show FOV",
		Default = ShowFOV,
		Callback = function(v)
			ShowFOV = v
		end
	})

	CombatTab:Slider({
		Title = "FOV Size",
		Step = 1,
		Value = {
			Min = 50,
			Max = 500,
			Default = FOV
		},
		Callback = function(v)
			FOV = v
		end
	})
end

--// ===== Get Player Names =====
local function GetPlayerNames()
	local t = {}
	for _, plr in pairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer then
			table.insert(t, plr.Name)
		end
	end
	return t
end

--// ===== Save Friend Dropdown (SilentAim Ignore) =====
CombatTab:Dropdown({
	Title = "Save Friend",
	Values = GetPlayerNames(),
	Multi = true,
	Default = {},
	Callback = function(selected)
		-- reset à¸—à¸¸à¸à¸„à¸™à¸à¹ˆà¸­à¸™
		for _, plr in pairs(Players:GetPlayers()) do
			plr:SetAttribute("SilentAimIgnore", false)
		end

		-- à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¹€à¸‰à¸žà¸²à¸°à¸Šà¸·à¹ˆà¸­à¸—à¸µà¹ˆà¹€à¸¥à¸·à¸­à¸
		for _, name in pairs(selected) do
			local plr = Players:FindFirstChild(name)
			if plr then
				plr:SetAttribute("SilentAimIgnore", true)
			end
		end
	end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local defaultJumpPower = 20
local maxJumpPower = 100
local highJumpPower = 60
local highJump = false

local function setJumpPower(power)
    local char = player.Character or player.CharacterAdded:Wait()
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.UseJumpPower = true
        hum.JumpPower = math.clamp(power, 0, maxJumpPower)
    end
end

local function setupCharacter(char)
    local hum = char:WaitForChild("Humanoid")
    hum.AutoJumpEnabled = false  

    if highJump then
        hum.UseJumpPower = true
        hum.JumpPower = highJumpPower
    else
        hum.JumpPower = defaultJumpPower
    end
end

player.CharacterAdded:Connect(setupCharacter)
if player.Character then
    setupCharacter(player.Character)
end

--// ===== High Jump =====
PlayersTab:Toggle({
    Title = "High Jump",
    Default = false,
    Callback = function(state)
        highJump = state
        if state then
            setJumpPower(highJumpPower)
        else
            setJumpPower(defaultJumpPower)
        end
    end
})

PlayersTab:Slider({
    Title = "Jump Power",
    Value = { Min = 20, Max = maxJumpPower, Default = highJumpPower },
    Step = 1,
    Callback = function(value)
        highJumpPower = tonumber(value)
        if highJump then
            setJumpPower(highJumpPower)
        end
    end
})

--// ===== Walk Speed =====
local walkSpeed = false
local speedMultiplier = 0.10

PlayersTab:Toggle({
    Title = "Walk Speed",
    Default = false,
    Callback = function(state)
        walkSpeed = state
    end
})

PlayersTab:Slider({
    Title = "Speed Multiplier",
    Value = { Min = 1, Max = 5, Default = speedMultiplier },
    Step = 1,
    Callback = function(value)
        speedMultiplier = tonumber(value)
    end
})

RunService.RenderStepped:Connect(function(delta)
    if walkSpeed and player.Character then
        local char = player.Character
        local hum = char:FindFirstChildOfClass("Humanoid")
        local root = char:FindFirstChild("HumanoidRootPart")
        if hum and root then
            local moveDir = hum.MoveDirection
            if moveDir.Magnitude > 0 then
                root.CFrame = root.CFrame + moveDir.Unit * speedMultiplier * delta * 1
            end
        end
    end
end)

-- Pickup Itemlocal Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HRP = Character:WaitForChild("HumanoidRootPart")

local PICKUP_DISTANCE = 350
local TOUCH_REPEAT = 25

local pickupEnabled = false

local function firetouch(partA, partB)
    for i = 1, TOUCH_REPEAT do
        firetouchinterest(partA, partB, 0)
        firetouchinterest(partA, partB, 1)
    end
end

RunService.RenderStepped:Connect(function()
    if pickupEnabled then
        for _, item in pairs(workspace.DroppedItems:GetChildren()) do
            local zone = item:FindFirstChild("PickUpZone")
            if zone and zone:IsA("BasePart") then
                local dist = (HRP.Position - zone.Position).Magnitude
                if dist <= PICKUP_DISTANCE then
                    firetouch(zone, HRP)
                end
            end
        end
    end
end)
PlayersTab:Toggle({
    Title = "Pickup Item",
    Default = false,
    Callback = function(state)
        pickupEnabled = state
    end
})

PlayersTab:Section({
	Title = 'Misc:',
})


PlayersTab:Button({
	Title = "Invisible",
	Callback = function()
		setfflag("NextGenReplicatorEnabledWrite4", "false")
		print("NextGenReplicatorEnabledWrite4 false")

		task.wait(2)

		setfflag("NextGenReplicatorEnabledWrite4", "true")
		print("NextGenReplicatorEnabledWrite4 true")
	end
})â€‹

PlayersTab:Section({
	Title = 'Snap:',
})

--// ================= Players Snap =================

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

-- State
local SnapEnabled = false
local SnapDepth = 10  -- à¸„à¹ˆà¸²à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™ 1â€“60

-- Snap Function
local function SnapLoop()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local root = character:WaitForChild("HumanoidRootPart")

    while SnapEnabled and root.Parent do
        task.wait(0.05)  -- à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¹‚à¸«à¸¥à¸”à¸ªà¸¹à¸‡
        local currentPos = root.Position
        root.CFrame = CFrame.new(currentPos.X, currentPos.Y - SnapDepth, currentPos.Z)
    end
end

-- Toggle UI
PlayersTab:Toggle({
    Title = "Snap",
    Value = false,
    Callback = function(state)
        SnapEnabled = state
        if state then
            task.spawn(SnapLoop)  -- à¹€à¸£à¸´à¹ˆà¸¡ loop
        end
    end
})

-- Slider UI
PlayersTab:Slider({
    Title = "Snap Depth",
    Value = {Min = 1, Max = 60, Default = SnapDepth},
    Step = 1,
    Callback = function(value)
        SnapDepth = value
        print("ðŸ“ Snap Depth:", SnapDepth)
    end
})


--// ================= ESP SYSTEM =================
local EspNameEnabled = false
local EspHealthEnabled = false
local EspDistanceEnabled = false

local EspCache = {}

local function CreateESP(plr)
	if EspCache[plr] then return end

	local nameText = Drawing.new("Text")
	nameText.Size = 12
	nameText.Center = true
	nameText.Outline = true
	nameText.Font = 2
	nameText.Color = Color3.fromRGB(255,255,255)
	nameText.Visible = false

	local healthText = Drawing.new("Text")
	healthText.Size = 12
	healthText.Center = true
	healthText.Outline = true
	healthText.Font = 2
	healthText.Color = Color3.fromRGB(0,255,0)
	healthText.Visible = false

	local distText = Drawing.new("Text")
	distText.Size = 12
	distText.Center = true
	distText.Outline = true
	distText.Font = 2
	distText.Color = Color3.fromRGB(255,255,0)
	distText.Visible = false

	EspCache[plr] = {
		Name = nameText,
		Health = healthText,
		Distance = distText
	}
end

local function RemoveESP(plr)
	if EspCache[plr] then
		for _, v in pairs(EspCache[plr]) do
			v:Remove()
		end
		EspCache[plr] = nil
	end
end

-- à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆ
for _, plr in pairs(Players:GetPlayers()) do
	if plr ~= LocalPlayer then
		CreateESP(plr)
	end
end

Players.PlayerAdded:Connect(function(plr)
	if plr ~= LocalPlayer then
		CreateESP(plr)
	end
end)

Players.PlayerRemoving:Connect(RemoveESP)

-- à¸§à¸²à¸”à¸—à¸¸à¸à¹€à¸Ÿà¸£à¸¡
RunService.RenderStepped:Connect(function()
	for plr, esp in pairs(EspCache) do
		local char = plr.Character
		local head = char and char:FindFirstChild("Head")
		local root = char and char:FindFirstChild("HumanoidRootPart")
		local hum = char and char:FindFirstChildOfClass("Humanoid")

		if head and root and hum then
			local headPos, headOn = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.6, 0))
			local footPos, footOn = Camera:WorldToViewportPoint(root.Position - Vector3.new(0, 3, 0))

			-- ESP NAME
			if EspNameEnabled and headOn then
				esp.Name.Text = plr.Name
				esp.Name.Position = Vector2.new(headPos.X, headPos.Y)
				esp.Name.Visible = true
			else
				esp.Name.Visible = false
			end

			-- ESP HEALTH %
			if EspHealthEnabled and headOn then
				local hp = math.floor((hum.Health / hum.MaxHealth) * 100)
				esp.Health.Text = hp .. "%"
				esp.Health.Position = Vector2.new(headPos.X, headPos.Y + 14)
				esp.Health.Visible = true
			else
				esp.Health.Visible = false
			end

			-- ESP DISTANCE
			if EspDistanceEnabled and footOn then
				local dist = (Camera.CFrame.Position - root.Position).Magnitude
				esp.Distance.Text = string.format("%.0f m", dist)
				esp.Distance.Position = Vector2.new(footPos.X, footPos.Y)
				esp.Distance.Visible = true
			else
				esp.Distance.Visible = false
			end
		else
			for _, v in pairs(esp) do
				v.Visible = false
			end
		end
	end
end)

--// ================= UI =================
EspTab:Toggle({
	Title = "ESP Name",
	Default = false,
	Callback = function(v)
		EspNameEnabled = v
	end
})

EspTab:Toggle({
	Title = "ESP Health",
	Default = false,
	Callback = function(v)
		EspHealthEnabled = v
	end
})

EspTab:Toggle({
	Title = "ESP Distance",
	Default = false,
	Callback = function(v)
		EspDistanceEnabled = v
	end
})

--// ================= ESP TRACER =================
local EspTracerEnabled = false
local TracerCache = {}

local function CreateTracer(plr)
	if TracerCache[plr] then return end

	local line = Drawing.new("Line")
	line.Color = Color3.fromRGB(0, 170, 255) -- à¸ªà¸µà¸Ÿà¹‰à¸²
	line.Thickness = 1.5
	line.Transparency = 1
	line.Visible = false

	TracerCache[plr] = line
end

local function RemoveTracer(plr)
	if TracerCache[plr] then
		TracerCache[plr]:Remove()
		TracerCache[plr] = nil
	end
end

-- à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆ
for _, plr in pairs(Players:GetPlayers()) do
	if plr ~= LocalPlayer then
		CreateTracer(plr)
	end
end

Players.PlayerAdded:Connect(function(plr)
	if plr ~= LocalPlayer then
		CreateTracer(plr)
	end
end)

Players.PlayerRemoving:Connect(RemoveTracer)

-- à¸§à¸²à¸”à¸—à¸¸à¸à¹€à¸Ÿà¸£à¸¡
RunService.RenderStepped:Connect(function()
	local viewSize = Camera.ViewportSize
	local fromPos = Vector2.new(viewSize.X / 2, 0) -- à¸šà¸™à¸ˆà¸­à¸à¸¥à¸²à¸‡

	for plr, line in pairs(TracerCache) do
		if not EspTracerEnabled then
			line.Visible = false
			continue
		end

		local char = plr.Character
		local root = char and char:FindFirstChild("HumanoidRootPart")

		if root then
			local pos, onScreen = Camera:WorldToViewportPoint(root.Position)

			if onScreen then
				line.From = fromPos
				line.To = Vector2.new(pos.X, pos.Y)
				line.Visible = true
			else
				line.Visible = false -- à¸«à¸±à¸™à¹„à¸›à¸—à¸²à¸‡à¸­à¸·à¹ˆà¸™ = à¸¥à¸šà¹€à¸ªà¹‰à¸™
			end
		else
			line.Visible = false
		end
	end
end)

--// ================= UI =================
EspTab:Toggle({
	Title = "ESP Tracer",
	Default = false,
	Callback = function(v)
		EspTracerEnabled = v
	end
})

EspTab:Toggle({
	Title = 'Inventory Viewer',
	Default = true,
	Callback = function(Value)
		_G.InventoryViewerEnabled = Value
		local Players = game:GetService('Players')
		local ReplicatedStorage = game:GetService('ReplicatedStorage')
		local Client = Players.LocalPlayer
		local function GetColorFromRarity(rarityName)
			local colors = {
				['Common'] = Color3.fromRGB(255, 255, 255),
				['UnCommon'] = Color3.fromRGB(99, 255, 52),
				['Rare'] = Color3.fromRGB(51, 170, 255),
				['Legendary'] = Color3.fromRGB(255, 150, 0),
				['Epic'] = Color3.fromRGB(237, 44, 255),
				['Omega'] = Color3.fromRGB(255, 20, 51),
			}
			return colors[rarityName] or Color3.fromRGB(255, 255, 255)
		end
		if Value then
			if not _G.ViewerRunning then
				_G.ViewerRunning = true
				task.spawn(function()
					while task.wait(0.2) do
						if not _G.InventoryViewerEnabled then
							continue
						end
						pcall(function()
							for _, v in pairs(Players:GetPlayers()) do
								if v ~= Client and v.Character and v.Character:FindFirstChild('HumanoidRootPart') then
									local root = v.Character.HumanoidRootPart
									local gui = root:FindFirstChild('ItemBillboard')
									if not gui then
										gui = Instance.new('BillboardGui')
										gui.Name = 'ItemBillboard'
										gui.AlwaysOnTop = true
										gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
										gui.Size = UDim2.new(0, 200, 0, 50)
										gui.StudsOffset = Vector3.new(0, -5, 0)
										gui.ExtentsOffset = Vector3.new(0, 1, 0)
										gui.LightInfluence = 1
										gui.Parent = root
										local bg = Instance.new('Frame')
										bg.Name = 'BG'
										bg.BackgroundTransparency = 1
										bg.Size = UDim2.new(1, 0, 1, 0)
										bg.AnchorPoint = Vector2.new(0.5, 0.5)
										bg.Position = UDim2.new(0.5, 0, 0.5, 0)
										bg.Parent = gui
										local layout = Instance.new('UIListLayout')
										layout.FillDirection = Enum.FillDirection.Horizontal
										layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
										layout.VerticalAlignment = Enum.VerticalAlignment.Center
										layout.Padding = UDim.new(0, 5)
										layout.Parent = bg
									end
									local bg = gui:FindFirstChild('BG')
									if not bg then
										continue
									end
									local Items = {}

                                    -- à¹€à¸„à¸¥à¸µà¸¢à¸£à¹Œà¸‚à¸­à¸‡à¹€à¸à¹ˆà¸²à¸à¹ˆà¸­à¸™
									for _, child in pairs(bg:GetChildren()) do
										if child:IsA('Frame') then
											child:Destroy()
										end
									end

                                    -- loop item à¹ƒà¸™ backpack + character
									for _, container in pairs({
										v:FindFirstChild('Backpack'),
										v.Character
									}) do
										if container then
											for _, tool in pairs(container:GetChildren()) do
												if tool:IsA('Tool') and not tool:GetAttribute('JobTool') and not tool:GetAttribute('Locked') then
													local itemFolder = tool:GetAttribute('AmmoType') and ReplicatedStorage.Items.gun or ReplicatedStorage.Items.melee
													for _, z in pairs(itemFolder:GetChildren()) do
														if tool:GetAttribute('RarityName') == z:GetAttribute('RarityName') and tool:GetAttribute('RarityPrice') == z:GetAttribute('RarityPrice') then
															local imageId = z:GetAttribute('ImageId')
															if imageId then
																Items[z.Name] = true
																if not bg:FindFirstChild(z.Name .. '_bg') then
																	local iconBg = Instance.new('Frame')
																	iconBg.Name = z.Name .. '_bg'
																	iconBg.Size = UDim2.new(0, 34, 0, 34)
																	iconBg.BackgroundColor3 = GetColorFromRarity(z:GetAttribute('RarityName'))
																	iconBg.BackgroundTransparency = 1
																	iconBg.BorderSizePixel = 0
																	iconBg.Parent = bg
																	local bgImage = Instance.new('ImageLabel')
																	bgImage.Name = 'Background'
																	bgImage.Size = UDim2.new(1, 0, 1, 0)
																	bgImage.BackgroundTransparency = 1
																	bgImage.Image = 'rbxassetid://137066731814190'
																	bgImage.ImageColor3 = GetColorFromRarity(z:GetAttribute('RarityName'))
																	bgImage.ZIndex = 0
																	bgImage.Parent = iconBg
																	local corner = Instance.new('UICorner')
																	corner.CornerRadius = UDim.new(0.15, 0)
																	corner.Parent = iconBg
																	local icon = Instance.new('ImageLabel')
																	icon.Name = z.Name
																	icon.Image = imageId
																	icon.BackgroundTransparency = 1
																	icon.BorderSizePixel = 0
																	icon.Size = UDim2.new(0.85, 0, 0.85, 0)
																	icon.Position = UDim2.new(0.075, 0, 0.075, 0)
																	icon.Parent = iconBg
																	local corner2 = Instance.new('UICorner')
																	corner2.CornerRadius = UDim.new(0, 9)
																	corner2.Parent = icon
																end
															end
														end
													end
												end
											end
										end
									end
									gui.Enabled = _G.InventoryViewerEnabled
									for _, child in pairs(bg:GetChildren()) do
										if child:IsA('Frame') then
											local itemName = child.Name:gsub('_bg$', '')
											if not Items[itemName] then
												child:Destroy()
											end
										end
									end
								end
							end
						end)
					end
				end)
			end
		else
            -- à¸¥à¸š GUI à¹€à¸¡à¸·à¹ˆà¸­à¸›à¸´à¸”
			for _, v in pairs(Players:GetPlayers()) do
				if v.Character and v.Character:FindFirstChild('HumanoidRootPart') then
					local gui = v.Character.HumanoidRootPart:FindFirstChild('ItemBillboard')
					if gui then
						gui:Destroy()
					end
				end
			end
		end
	end  -- à¸›à¸´à¸” Callback function
})  -- à¸›à¸´à¸” table à¸‚à¸­à¸‡ Toggle

ServerTab:Section({
	Title = 'Server Information:',
})

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸”à¸¶à¸‡à¸£à¸«à¸±à¸ª Server
local function GetJobID()
	return game.JobId or "Unknown"
end

-- à¹à¸ªà¸”à¸‡ Server Code
local ServerCodeLabel = ServerTab:Code({
	Title = 'Current Server',
	Code = 'Server Code: ' .. GetJobID()
})

ServerTab:Divider()

ServerTab:Section({
	Title = 'Server Utilities:',
})

-- à¸Šà¹ˆà¸­à¸‡à¸à¸£à¸­à¸à¹‚à¸„à¹‰à¸” Server
local ServerCode = ''

ServerTab:Input({
	Title = 'Enter Server Code',
	Placeholder = 'Paste server JobId here...',
	Callback = function(Value)
		ServerCode = Value
	end
})

-- à¸›à¸¸à¹ˆà¸¡ Join Server à¸”à¹‰à¸§à¸¢à¹‚à¸„à¹‰à¸”
ServerTab:Button({
	Title = 'Join by Code',
	Icon = 'log-in',
	Callback = function()
		if ServerCode == '' then
			warn('à¹ƒà¸ªà¹ˆcodeà¸”à¸´à¸™à¹‰à¸­à¸‡')
			return
		end
		local TeleportService = game:GetService('TeleportService')
		TeleportService:TeleportToPlaceInstance(game.PlaceId, ServerCode, game.Players.LocalPlayer)
	end
})


ServerTab:Button({
	Title = 'Rejoin Current Server',
	Icon = 'refresh-ccw',
	Callback = function()
		local TeleportService = game:GetService('TeleportService')
		TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
	end
})

ServerTab:Button({
	Title = 'Hop Server',
	Icon = 'shuffle',
	Callback = function()
		local HttpService = game:GetService('HttpService')
		local TeleportService = game:GetService('TeleportService')
		local servers = {}
		local req = game:HttpGet(
            string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100", game.PlaceId)
        )
		local data = HttpService:JSONDecode(req)
		if data and data.data then
			for _, v in pairs(data.data) do
				if v.playing < v.maxPlayers then
					table.insert(servers, v.id)
				end
			end
		end
		if #servers > 0 then
			TeleportService:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], game.Players.LocalPlayer)
		end
	end
})
